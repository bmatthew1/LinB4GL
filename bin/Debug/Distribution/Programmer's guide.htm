<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>Basic4GL - Programmer's guide</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<META content="MSHTML 6.00.6000.16705" name=GENERATOR></HEAD>
<BODY bgColor=#ffffff>
<P><FONT size=5>Basic4GL, Copyright (C) 2003-2007 Tom Mulgrew</FONT></P>
<P><FONT size=5>Programmer's guide</FONT></P>
<P>26-Jul-2008<BR>Tom Mulgrew</P>
<H1>This document</H1>
<P>This document describes the various functions, and how to use them to do 
something useful in Basic4GL. <BR>It does not go into great detail about the 
language syntax itself (see the Language Guide if that is what you need).<BR>It 
does not go into detail about OpenGL programming (see the OpenGL guide for 
that.)</P>
<H1>Text output</H1>
<H2>Basic text output</H2>
<H3>Print</H3>
<P>Basic text output is performed using the "Print" or "Printr" function.</P>
<P>Format:</P>
<BLOCKQUOTE>
  <P>Print <EM>text-parameters</EM> ;</P></BLOCKQUOTE>
<P>Or:</P>
<BLOCKQUOTE>
  <P>Print <EM>text-parameters</EM></P></BLOCKQUOTE>
<P>Where <EM>text-parameters</EM> is a list of parameters, separated by 
semicolons (;).</P>
<P>"Print" leaves the cursor positioned after the last character printed.</P>
<P>"Printr" will automatically move the cursor to the start of the next line 
after the text has been printed.<BR>If the cursor reaches the bottom of the 
screen, the text will scroll up the screen to make room for the new line.</P>
<P>Example:</P>
<BLOCKQUOTE><PRE>Printr "Hello ";
Printr "and welcome to ";
Printr "Basic4GL"
Print
Print "Have a nice day"</PRE></BLOCKQUOTE>
<TABLE borderColor=#000000 cellSpacing=0 borderColorDark=#000000 cellPadding=0 
width="100%" bgColor=#ded8fc borderColorLight=#000000 border=1>
  <TBODY>
  <TR>
    <TD><FONT size=3><STRONG>Traditional BASIC syntax</STRONG></FONT> 
      <P><FONT size=2>"Print" behaves slightly differently when "traditional 
      BASIC" syntax is enabled, or "Basic4GL with traditional print" syntax is 
      enabled.<BR>(You can enable the "traditional BASIC" syntax by placing a 
      </FONT></P>
      <BLOCKQUOTE><PRE><FONT size=2>language traditional</FONT></PRE></BLOCKQUOTE>
      <P><FONT size=2>line at the top of your program, or</FONT></P>
      <BLOCKQUOTE><PRE><FONT size=2>language traditional_print</FONT></PRE></BLOCKQUOTE>
      <P><FONT size=2>for just the print command syntax.)</FONT></P>
      <P><FONT size=2>In this mode, the "print" command will move the cursor to 
      the next line if it does not end with a trailing semicolon (;)</FONT></P>
      <P><FONT size=2>For example:</FONT></P>
      <BLOCKQUOTE><PRE><FONT size=2>language traditional
print "Line 1"
print "Line 2"
print "Line 3"</FONT></PRE></BLOCKQUOTE>
      <P><FONT size=2>Will print:</FONT></P>
      <BLOCKQUOTE>
        <P><FONT size=2>Line1<BR>Line2<BR>Line3</FONT></P></BLOCKQUOTE>
      <P><FONT size=2>If the "print" command does end with a semicolon, then the 
      cursor will remain on the same line. So:</FONT></P>
      <BLOCKQUOTE><PRE><FONT size=2>language traditional
print "Welcome ";
print "to ";
print "Basic4GL"</FONT></PRE></BLOCKQUOTE>
      <P><FONT size=2>Will print:</FONT></P>
      <BLOCKQUOTE>
        <P><FONT size=2>Welcome to Basic4GL</FONT></P></BLOCKQUOTE>
      <P><FONT size=2>Thus the "printr" command is not required in this syntax 
      (but it is still available for compatibility 
  sake).</FONT></P></TD></TR></TBODY></TABLE>
<H3>Locate</H3>
<P>Locate positions the text cursor on the screen.</P>
<P>Format:</P>
<BLOCKQUOTE>
  <P>Locate <EM>X-position</EM>, <EM>Y-position</EM></P></BLOCKQUOTE>
<P>The Basic4GL text cursor is invisible. It determines to where on the screen 
"Print" and "Printr" will write.</P>
<P>By default the Basic4GL displays 40 characters across by 25 characters down 
(this can be changed using the "ResizeText()" function).</P>
<P>The topmost row is row 0.<BR>The leftmost column is column 0.</P>
<P>Example:</P>
<BLOCKQUOTE>
  <P>Dim d#<BR>While True<BR>Cls<BR>Locate Sin (d#) * 15 + 18, 10<BR>Print 
  "Hello"<BR>Sleep (100)<BR>d# = d# + 0.1<BR>Wend</P></BLOCKQUOTE>
<H3>CursorCol, CursorRow</H3>
<P>CursorCol() returns the column the cursor is on.<BR>CursorRow() returns the 
row the cursor is on.</P>
<P>The topmost row is row 0.<BR>The leftmost column is column 0.</P>
<H3>Color</H3>
<P>Sets the text colour.</P>
<P>Format:</P>
<BLOCKQUOTE>
  <P>Color (<EM>red</EM>, <EM>green</EM>, <EM>blue</EM>)</P></BLOCKQUOTE>
<P>Where <EM>red</EM>, <EM>green</EM> and <EM>blue</EM> are integers between 0 
and 255 inclusive indicating the intensity of their respective colour 
component.</P>
<P>Once the text colour is set, any text printed will be in that colour until 
the text colour is changed.</P>
<P>Example:</P>
<BLOCKQUOTE><PRE>dim t<BR>TextMode (TEXT_BUFFERED)<BR>while true<BR>    for t = 1 to 10: color (rnd()%255, rnd()%255, rnd()%255): print chr$(rnd()%255): next<BR>    DrawText ()<BR>wend</PRE></BLOCKQUOTE>
<H3>Cls</H3>
<P>Cls clears all text from the screen and repositions the cursor to the top 
left.</P>
<H3>ClearLine</H3>
<P>ClearLine () clears the current line (the one which the cursor is on).</P>
<P>Example:</P>
<BLOCKQUOTE><PRE>dim i
SetTextScroll (false)
for i = 0 to 24: printr i: next
locate 0, 10
ClearLine ()		' Line 10 is cleared</PRE></BLOCKQUOTE>
<H3>ClearRegion</H3>
<P>Cears a rectangular region of the screen.</P>
<P>Format:</P>
<BLOCKQUOTE>
  <P>ClearRegion (<EM>x1</EM>, <EM>y1</EM>, <EM>x2</EM>, 
<EM>y2</EM>)</P></BLOCKQUOTE>
<P>Where <EM>x1</EM>, <EM>y1</EM>, <EM>x2</EM>, <EM>y2</EM> are integers that 
define the top left column and row (<EM>x1</EM>, <EM>y1</EM>) and the bottom 
right column and row (<EM>x2</EM>, <EM>y2</EM>) of the rectangular region to be 
cleared.</P>
<P>Example:</P>
<BLOCKQUOTE><PRE>dim x, y
SetTextScroll (false)
TextMode (TEXT_BUFFERED)
for y = 1 to TextRows ()
    for x = 1 to TextCols ()
        print "#"
    next
next
ClearRegion (5, 5, 35, 9)
locate 13, 7: print "Cleared region"
DrawText ()</PRE></BLOCKQUOTE>
<H3>TextRows, TextCols and ResizeText</H3>
<P>TextRows () returns the number of text columns.<BR>TextCols () returns the 
number of text rows.</P>
<P>ResizeText (<EM>x</EM>, <EM>y</EM>) resizes the text display to <EM>y</EM> 
rows by <EM>x</EM> columns and clears the text.</P>
<P>Example:</P>
<BLOCKQUOTE><PRE>dim i, a$<BR>a$ = "Basic4GL"<BR>i = 100<BR>while i &gt;= 4<BR>    ResizeText (i * 2 + 1, i + 1)<BR>    Locate (TextCols() - Len(a$)) / 2, TextRows() / 2<BR>    Print a$<BR>    Sleep (50)<BR>    i = i - 2<BR>wend</PRE></BLOCKQUOTE>
<H3>Text scrolling</H3>
<P>Advancing the cursor past the end of the line causes it to wrap around onto 
the next line.</P>
<P>Advancing the cursor past the end of the bottom-most line, or performing a 
Printr on the bottom-most line causes the text to scroll up by one line.</P>
<P>Example 1:</P>
<BLOCKQUOTE><PRE>Print glGetString (GL_EXTENSIONS)</PRE></BLOCKQUOTE>
<P>Example 2:</P>
<BLOCKQUOTE><PRE>dim d#<BR>while true<BR>    locate sin(d#)*15+17, TextRows()-1<BR>    Printr "Hello"<BR>    Sleep (50)<BR>    d# = d# + 0.3<BR>wend</PRE></BLOCKQUOTE>
<P>Alternatively you can disable text scrolling with the TextScroll command.</P>
<H3>SetTextScroll</H3>
<P>SetTextScroll () enables or disables text scrolling when the cursor reaches 
the bottom of the text screen.</P>
<P>Format:</P>
<BLOCKQUOTE>
  <P>SetTextScroll (<EM>scroll</EM>)</P></BLOCKQUOTE>
<P>Where <EM>scroll</EM> can equal <STRONG>true</STRONG> to enable text 
scrolling or <STRONG>false</STRONG> to disable it. Text scrolling is 
<EM>enabled</EM> by default.</P>
<P>Example:</P>
<BLOCKQUOTE><PRE>SetTextScroll (false)
dim row
print "########################################"
for row = 2 to 24
    print "#                                      #"
next
print "########################################"</PRE></BLOCKQUOTE>
<H3>TextScroll</H3>
<P>TextScroll () returns <STRONG>true</STRONG> if text scrolling is enabled, or 
false if it isn't.</P>
<H2>Fonts</H2>
<P>Basic4GL fonts are special transparent images, consisting of a 16 x 16 grid 
of characters. You can set a new font by calling:</P>
<BLOCKQUOTE>
  <P>Font (<EM>texture</EM>)</P></BLOCKQUOTE>
<P>Where <EM>texture</EM> is an OpenGL texture handle (usually returned from 
LoadTex()).</P>
<P>Example:</P>
<BLOCKQUOTE><PRE>printr "Normal font"
dim texture
texture = LoadTex("data\charset2.png")
Font (texture)
printr "charset2.png font"</PRE></BLOCKQUOTE>
<P>To get the texture handle for the default font, call:</P>
<BLOCKQUOTE>
  <P>DefaultFont ()</P></BLOCKQUOTE>
<P>Example:</P>
<BLOCKQUOTE><PRE>dim texture
texture = LoadTex("data\charset2.png")
Font (texture)
printr "charset2.png font"
Font (DefaultFont ())
printr "Normal font"</PRE></BLOCKQUOTE>
<H2>Text modes</H2>
<P>Basic4GL has 3 different modes for rendering text on the screen. You choose 
one by executing the appropriate TextMode() call:</P>
<UL>
  <LI>TextMode (TEXT_SIMPLE) 
  <LI>TextMode (TEXT_BUFFERED) 
  <LI>TextMode (TEXT_OVERLAID) </LI></UL>
<P>The default mode is TEXT_SIMPLE.<BR>In this mode, Basic4GL redraws the screen 
after each "Print", "Printr", "Cls" or "ResizeText()".</P>
<P>This mode is easy to use, and the results are instant. However there are a 
number of situations where you may find it favourable to use TEXT_BUFFERED.</P>
<P>In TEXT_BUFFERED mode, Basic4GL does not update the screen until you call 
DrawText ().<BR>This has advantages if you are animating a large amount of 
text:</P>
<OL>
  <LI>Reduces flicker.<BR>The screen is only updated once all text has been 
  drawn.<BR>
  <LI>Reduces screen resync delay.<BR>Depending on your video card and OpenGL 
  settings, your OpenGL system may wait for vertical syncronisation before every 
  screen update.<BR>This can lead to unnecessarily slow animations in 
  TEXT_SIMPLE mode, as Basic4GL must stop and wait for vertical resync after 
  every "Print" statement. </LI></OL>
<P>However, you must remember to call DrawText() or the user won't see any 
changes.</P>
<P>Example:</P>
<BLOCKQUOTE><PRE>TextMode (TEXT_BUFFERED)<BR>dim d#, t<BR>while true<BR>    for t = 1 to 10<BR>        Locate sin(d#*t/19.0+t)*14+14,t*2+1<BR>        print " Thing "<BR>    next<BR>    DrawText ()<BR>    Sleep (10)<BR>    d# = d# + .1<BR>wend</PRE></BLOCKQUOTE>
<P>TEXT_OVERLAID mode is used to combine OpenGL graphics with text.<BR>This mode 
is necessary if you wish to use OpenGL graphics commands and text <EM>at the 
same time</EM>.</P>
<P>This would cause problems in TEXT_SIMPLE or TEXT_BUFFERED mode, as both modes 
automatically clear the screen before rendering the text.</P>
<P>In TEXT_OVERLAID mode the DrawText() function will not clear the screen, or 
copy the result to the front buffer. It will simply render the current text 
transparently over the top of the current scene.<BR>You must therefore manually 
clear the screen and swap it to the font buffer at the appropriate times.</P>
<P>The advantage of this mode is that it gives you a finer degree of control, 
and allows you to combine text and other graphics, such as OpenGL rendered 
objects.</P>
<P>Example:</P>
<BLOCKQUOTE><PRE>TextMode (TEXT_OVERLAID)<BR>locate 12, 12: print "This is a square"<BR><BR>dim a#<BR>while true<BR>    glClear (GL_DEPTH_BUFFER_BIT or GL_COLOR_BUFFER_BIT)<BR>    glLoadIdentity ()<BR>    glTranslatef (0, 0, -2)<BR>    glRotatef (a#, 0, 0, 1)<BR>    glBegin (GL_QUADS)<BR>        glColor3f (1, 0, 0): glVertex2f ( 1, 1)<BR>        glColor3f (0, 1, 0): glVertex2f (-1, 1)<BR>        glColor3f (0, 0, 1): glVertex2f (-1,-1)<BR>        glColor3f (1, 1, 1): glVertex2f ( 1,-1)<BR>    glEnd ()<BR>    DrawText ()<BR>    SwapBuffers () <BR>    a# = a# + 0.3<BR>wend</PRE></BLOCKQUOTE>
<H3>DrawText</H3>
<P>Format:</P>
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
  <P>DrawText()<BR>DrawText(<EM>flags</EM>)</P></BLOCKQUOTE>
<P>The DrawText command is used to draw text and/or sprites. The default (no 
parameter) version draws all text and sprites that are on the screen. 
Alternatively you can control what it draws by passing it a bitmask composed of 
one or more of the following flags:</P>
<TABLE>
  <TBODY>
  <TR>
    <TD>DRAW_TEXT</TD>
    <TD>Draw text&nbsp;</TD></TR>
  <TR>
    <TD>DRAW_SPRITES_BEHIND</TD>
    <TD>Draw all sprites behind the text&nbsp;</TD></TR>
  <TR>
    <TD>DRAW_SPRITES_INFRONT</TD>
    <TD>Draw all sprites infront&nbsp;of the text&nbsp;</TD></TR>
  <TR>
    <TD>DRAW_SPRITES</TD>
    <TD>Draw all sprites behind or infront of the 
text&nbsp;</TD></TR></TBODY></TABLE>
<P>Example:</P>
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px"><PRE>TextMode(TEXT_OVERLAID)<BR>glDisable(GL_DEPTH_TEST)</PRE><PRE>' Create some bouncing balls<BR>const ballcount = 100<BR>dim tex = LoadTex("data/ball.png")<BR>dim sprites(ballcount), i<BR>for i = 1 to ballcount<BR>&nbsp;&nbsp;&nbsp; sprites(i) = NewSprite(tex)<BR>&nbsp;&nbsp;&nbsp; if rnd()%2 then SprSetZOrder(-1) endif<BR>&nbsp;&nbsp;&nbsp; SprSetPos(rnd() % 640, rnd() % 480)<BR>&nbsp;&nbsp;&nbsp; if rnd()%2 then SprSetXVel(1) else SprSetXVel(-1) endif<BR>&nbsp;&nbsp;&nbsp; if rnd()%2 then SprSetYVel(1) else SprSetYVel(-1) endif<BR>next</PRE></BLOCKQUOTE>
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px"><PRE>do<BR>    ' Clear the screen background&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; glBegin(GL_QUADS)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glColor3f(.5, 0, 0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex3f(-10,&nbsp; 10, -5)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex3f( 10,&nbsp; 10, -5)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glColor3f(0, 0, .5)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex3f( 10, -10, -5)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex3f(-10, -10, -5)<BR>&nbsp;&nbsp;&nbsp; glEnd()</PRE><PRE>    ' Draw behind sprites and small text<BR>&nbsp;&nbsp;&nbsp; ResizeText(80, 50)<BR>&nbsp;&nbsp;&nbsp; locate 35, 20: print "Small text"<BR>&nbsp;&nbsp;&nbsp; DrawText(DRAW_SPRITES_BEHIND or DRAW_TEXT)<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; ' Draw large text and infront sprites<BR>    ResizeText(20, 12)<BR>&nbsp;&nbsp;&nbsp; locate 6, 7: print "Big text"<BR>&nbsp;&nbsp;&nbsp; DrawText(DRAW_TEXT or DRAW_SPRITES_INFRONT)</PRE><PRE>&nbsp;&nbsp;&nbsp; ' Show completed frame<BR>    SwapBuffers()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; ' Animate bouncing balls<BR>    while SyncTimer(10)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AnimateSprites()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i = 1 to ballcount<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BindSprite(sprites(i))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if SprX() &lt; 0 or SprX() &gt; 640 then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SprSetXVel(-SprXVel())<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if SprY() &lt; 0 or SprY() &gt; 480 then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SprSetYVel(-SprYVel())<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next<BR>&nbsp;&nbsp;&nbsp; wend<BR>loop</PRE></BLOCKQUOTE>
<H2>Reading from the screen</H2>
<H3>CharAt$</H3>
<P>CharAt$(<EM>x</EM>, <EM>y</EM>) returns the character at column x and row 
y.</P>
<P>Example:</P>
<BLOCKQUOTE><PRE>TextMode(TEXT_BUFFERED)<BR>dim d#, t, x, y, crash: crash = false: x = TextCols()/2<BR>while not crash<BR>    for t = 1 to 5: locate sin(d#+t)*15+15,t*2+2: print" Thing! ": next<BR>    y=y-1<BR>    if y&lt;0 then <BR>        y = TextRows()-1: cls<BR>    else<BR>        if ScanKeyDown(VK_LEFT) and x &gt; 2 then x = x - 1 endif<BR>        if ScanKeyDown(VK_RIGHT) and x &lt; 36 then x = x + 1 endif<BR>        crash = CharAt$(x,y)&lt;&gt;" "<BR>        locate x, y: print"X"<BR>    endif <BR>    DrawText()<BR>    WaitTimer (80)<BR>    d# = d#+0.06<BR>wend</PRE></BLOCKQUOTE>
<H1>Timing</H1>
<H2>Sleep</H2>
<P>Pauses execution for a number of milliseconds.</P>
<P>Format:</P>
<BLOCKQUOTE>
  <P>Sleep (<EM>milliseconds</EM>)</P></BLOCKQUOTE>
<P>Note: The application is completely unresponsive while sleeping. Therefore 
Basic4GL will not sleep for more than 5000 msec (5 seconds) at a time.<BR>To 
sleep for more than 5 seconds, use a loop.<BR>For example:</P>
<BLOCKQUOTE><PRE>Dim i<BR>For i = 1 to 60: Sleep (1000): Next</PRE></BLOCKQUOTE>
<P>Will pause for 60 seconds, but still give the user the opportunity to break 
out of the program if he/she wishes.</P>
<H2>WaitTimer, SyncTimer and ResetTimer</H2>
<H3>WaitTimer</H3>
<P>This function is similar to Sleep, and indeed has the same format:</P>
<BLOCKQUOTE>
  <P>WaitTimer (<EM>milliseconds</EM>)</P></BLOCKQUOTE>
<P>The difference is that WaitTimer waits until <EM>milliseconds</EM> 
milliseconds has elapsed <EM>from the previous WaitTimer call</EM>.</P>
<P>This difference is significant if WaitTimer is used inside an animation loop, 
with other code that may take some time to execute (such as rendering a 
frame).<BR>For example:</P>
<BLOCKQUOTE>
  <P>While true<BR><EM>Draw a frame<BR></EM>WaitTimer 
(100)<BR>Wend</P></BLOCKQUOTE>
<P>If <EM>Draw a frame</EM> were to take 40 milliseconds, then WaitTimer will 
pause for only 60 milliseconds, ensuring that the loop is correctly iterated 10 
times a second.</P>
<P>Even simple animations can potentially take up to the resync period of the 
monitor (anything from 1/100th to 1/50th of a second), if the user's graphics 
card is configured to wait for retrace before drawing.</P>
<H3>SyncTimer</H3>
<P>SyncTimer returns true if you need to update the internal state of the 
application to catch up to the clock.</P>
<P>This can be used to force an animation to update internally so many times per 
second, regardless of a PC's rendering speed, and is intended to be used as 
follows:</P>
<BLOCKQUOTE>
  <P>While <EM>main-loop-condition</EM><BR><EM>Render scene</EM><BR>While 
  SyncTimer (<EM>delay</EM>)<BR><EM>Update state</EM><BR>Wend</P></BLOCKQUOTE>
<P>For example, if <EM>delay</EM> was 10 milliseconds, then <EM>Update 
state</EM> will execute 100 times per second, regardless of whether the computer 
is capable of rendering 20 or 100 frames per second.</P>
<P>Example:</P>
<BLOCKQUOTE><PRE>dim x, y, a#, b#<BR>while true<BR>    glClear (GL_DEPTH_BUFFER_BIT or GL_COLOR_BUFFER_BIT)<BR>    glLoadIdentity ()<BR>    glTranslatef (0, 0, -16)<BR>    glRotatef (a#, 0, 0, 1)<BR>    for y = -5 to 5: for x = -5 to 5<BR>        glPushMatrix ()<BR>        glTranslatef (x * 3, y * 3, 0)<BR>        glRotatef ((x + y) * 60 + b#, 1, 0, 0)<BR>        glBegin (GL_QUADS)<BR>            glColor3f (1, 0, 0): glVertex2f ( 1, 1)<BR>            glColor3f (0, 1, 0): glVertex2f (-1, 1)<BR>            glColor3f (0, 0, 1): glVertex2f (-1,-1)<BR>            glColor3f (1, 1, 1): glVertex2f ( 1,-1)<BR>        glEnd ()<BR>        glPopMatrix ()<BR>    Next: Next<BR>    SwapBuffers ()<BR>    while SyncTimer (10)<BR>        a# = a# + 0.9: b# = b# + 3.6<BR>    wend<BR>wend</PRE></BLOCKQUOTE>
<H1>Keyboard input</H1>
<H2>Text input</H2>
<H3>Input</H3>
<P>Reads a text string from the keyboard.</P>
<P>Format:</P>
<BLOCKQUOTE>
  <P>Input <EM>variable</EM></P>
  <P>Input "<EM>prompt</EM>"; <EM>variable</EM></P>
  <P>Input "<EM>prompt</EM>", <EM>variable</EM></P></BLOCKQUOTE>
<P>Input will pause the program and wait until the user types in some text and 
hits enter. The text will be displayed on the screen as the user types.<BR>If a 
<EM>prompt</EM> is given, it will be displayed on the screen. The first format 
(with the semicolon) automatically displays a question mark after the 
<EM>prompt</EM>. The second format (with the comma) simply displays the 
<EM>prompt</EM> and nothing else.</P>
<P>Once the user has hit enter, the program will continue, and <EM>variable</EM> 
will contain the resulting text or number that the user entered.</P>
<P>Examples:</P>
<BLOCKQUOTE><PRE>dim name$
input "What is your name"; name$
print "Hello " + name$</PRE></BLOCKQUOTE>
<BLOCKQUOTE><PRE>dim number
input "Please enter a number: ", number
print "The square root of " + number + " is " + sqrt (number)</PRE></BLOCKQUOTE>
<P><EM>Note: Be aware that Basic4GL's implementation of "input" is not as 
complete as other BASICs.<BR>Basic4GL does not support inputting multiple 
variables with the same input command.<BR>Also, Basic4GL will not prompt the 
user to "Redo from start" if the text he/she entered cannot be converted into 
the destination variable type. Instead it will simply set the destination 
variable to 0.</EM></P>
<P><EM>Note 2: There is an older Input$() function that has the syntax:</EM></P>
<BLOCKQUOTE>
  <P><EM>variable</EM> = Input$()</P></BLOCKQUOTE>
<P><EM>This is an old syntax, and kept only for backwards compatibility with 
older Basic4GL programs.</EM></P>
<H2>Key state</H2>
<H3>KeyDown and ScanKeyDown</H3>
<P>Determines whether a key is currently pressed or released.</P>
<P>Format:</P>
<BLOCKQUOTE>
  <P>KeyDown(<EM>character</EM>)</P>
  <P>ScanKeyDown(<EM>scan-code</EM>)</P></BLOCKQUOTE>
<P>KeyDown takes the first character of the string argument passed to it. 
<BR>ScanKeyDown takes a numeric virtual key code, often a VK_x constant (such as 
VK_UP e.t.c. Click "Help|Functions and Constants list..." then the "Constants" 
tab for a list).</P>
<P>Both functions return true (-1) if the key is being pressed or false (0) if 
otherwise.</P>
<P>Note: KeyDown("") will always return false.</P>
<P>Example 1:</P>
<BLOCKQUOTE><PRE>ResizeText (5, 1)<BR>while true<BR>    locate 0, 0<BR>    if KeyDown ("A") then print "Down"<BR>    else print " Up "<BR>    endif<BR>wend</PRE></BLOCKQUOTE>
<P>Example 2:</P>
<BLOCKQUOTE><PRE>dim a#<BR>while true<BR>    glClear (GL_DEPTH_BUFFER_BIT or GL_COLOR_BUFFER_BIT)<BR>    glLoadIdentity ()<BR>    glTranslatef (0, 0, -5)<BR>    glRotatef (a#, 0, 0, 1)<BR>    glBegin (GL_TRIANGLES)<BR>        glVertex2f ( 0, 1.5)<BR>        glVertex2f (-1,-1)<BR>        glVertex2f ( 1,-1)<BR>    glEnd ()<BR>    SwapBuffers () <BR>    while SyncTimer (10)<BR>        if ScanKeyDown (VK_LEFT) then a# = a# + 3: endif<BR>        if ScanKeyDown (VK_RIGHT) then a# = a# - 3: endif<BR>    wend<BR>wend</PRE></BLOCKQUOTE>
<H2>Buffered input</H2>
<H3>Inkey$ and InScanKey</H3>
<P>Format:</P>
<BLOCKQUOTE>
  <P>Inkey$ ()</P>
  <P>InScanKey ()</P></BLOCKQUOTE>
<P>Basic4GL buffers characters and raw scan codes typed into the output 
window.</P>
<P>Inkey$ () returns characters typed as single character strings. If no 
characters are buffered, Inkey$ () will return an empty string.</P>
<P>InScanKey () returns scan codes as integers. If no scan codes are buffered, 
InScanKey () returns 0.</P>
<P>Example:</P>
<BLOCKQUOTE><PRE>while true: print Inkey$ (): wend</PRE></BLOCKQUOTE>
<H3>ClearKeys</H3>
<P>Format:</P>
<BLOCKQUOTE>
  <P>ClearKeys ()</P></BLOCKQUOTE>
<P>ClearKeys () clears the keyboard buffer, throwing away any keypresses that 
have yet to be handled by Inkey$ () or InScanKey ().</P>
<P>ClearKeys () is equivalent to the following code:</P>
<BLOCKQUOTE><PRE>While Inkey$() &lt;&gt; "": wend
While InScanKey() &lt;&gt; 0: wend</PRE></BLOCKQUOTE>
<H1>Mouse input</H1>
<H2>Mouse functions</H2>
<P>The following functions can be used to read the mouse.</P>
<H3>Mouse_X, Mouse_Y</H3>
<P>These functions return the position of the mouse in relation to the OpenGL 
window (if in windowed mode), or the screen (fullscreen mode).</P>
<P>Mouse_X() returns the X (horizontal) position.<BR>Mouse_Y() returns the Y 
(vertical) position.</P>
<P>Both functions return a real value between 0 (far left, or top) and 1 (far 
right, or bottom).</P>
<P>Example 1:</P>
<BLOCKQUOTE>
  <P>print Mouse_X () + ", " + Mouse_Y (): run</P></BLOCKQUOTE>
<P>Example 2:</P>
<BLOCKQUOTE><PRE>ResizeText (80, 50)
dim x, y, char$
while true
    if not Mouse_Button (MOUSE_LBUTTON) then
        locate x, y: print char$
    endif
    x = Mouse_X () * TextCols ()
    y = Mouse_Y () * TextRows ()
    char$ = CharAt$ (x, y)
    locate x, y: print "X"
wend</PRE></BLOCKQUOTE>
<H3>Mouse_Button</H3>
<P>Mouse_Button (<EM>index</EM>) returns true if button <EM>index</EM> is being 
pressed, or false if it isn't.</P>
<P>The left mouse button is index 0, the right is index 1 and the middle is 
index 2.<BR>Alternatively you can use the following constants:</P>
<P>Left button: MOUSE_LBUTTON<BR>Right button: MOUSE_RBUTTON<BR>Middle button: 
MOUSE_MBUTTON</P>
<P>Example:</P>
<BLOCKQUOTE><PRE>dim i               
print "Press the mouse buttons!"
while true
    locate 0, 2
    for i = 0 to 2: printr Mouse_Button (i) + " ": next
wend</PRE></BLOCKQUOTE>
<H3>Mouse_Wheel</H3>
<P>Mouse_Wheel() returns how many notches the mouse wheel has turned since the 
last time Mouse_Wheel() was called (or the program started).</P>
<P>For example:</P>
<BLOCKQUOTE><PRE>dim i
print "Turn the mouse wheel!"
while true
    i = i + Mouse_Wheel ()
    locate 0, 2: print i + "    "
wend</PRE></BLOCKQUOTE>
<H3>Mouse_XD(), Mouse_YD()</H3>
<P>These functions return how far the mouse has moved since the last time 
Mouse_XD() or Mouse_YD() was called (respectively).</P>
<P>Mouse_XD() returns the X (horizontal) distance.<BR>Mouse_YD() returns the Y 
(vertical) distance.</P>
<P>These functions are useful for first person shooter type movement, where the 
mouse is used to turn the player, instead of controlling a pointer on the 
screen.</P>
<P><EM>Note: Mouse_XD() and Mouse_YD() work internally by positioning the mouse 
pointer in the middle of the window and measuring how far the mouse moves from 
that position. This means that using Mouse_X() or Mouse_Y() will produce 
unexpected results, and it is recommended you stick to one method or the 
other.</EM></P>
<P>Example:</P>
<BLOCKQUOTE><PRE>dim x#, z#
while true
    glClear (GL_DEPTH_BUFFER_BIT or GL_COLOR_BUFFER_BIT)
    glLoadIdentity ()
    glTranslatef (0, 0, -4)
    glRotatef (z#, 0, 0, 1)
    glRotatef (x#, 1, 0, 0)
    glBegin (GL_TRIANGLES)
        glVertex2f (0, 1)
        glVertex2f (-.5, -1)
        glVertex2f ( .5, -1)
    glEnd ()
    SwapBuffers ()
    z# = z# - Mouse_XD () * 100
    x# = x# + Mouse_YD () * 100
wend</PRE></BLOCKQUOTE>
<H1>Joystick input</H1>
<P><EM>Note: A big thanks to Tyler Bingham for implementing the joystick 
support!</EM></P>
<P>Basic4GL supports input from a single joystick. If more than one joystick is 
attached to a PC, Basic4GL will use whatever one the operating system says is 
first.</P>
<H2>Joystick functions</H2>
<P>The following functions can be used to read the joystick.</P>
<H3>Joy_Keys</H3>
<P>Joy_Keys() takes a snapshot of the joystick and generates appropriate 
keypresses. Arrow keys are generated for stick movement, and space bar and 
control (Ctrl) keypresses are generated for joystick buttons 0 and 1 
respectively.</P>
<P>The keypresses can then be detected with the keyboard input functions:</P>
<UL>
  <LI>InScanKey () 
  <LI>KeyDown (...) 
  <LI>ScanKeyDown () </LI></UL>
<P><EM>Note that Inkey$() is </EM><EM><STRONG>not </STRONG></EM><EM>affected by 
Joy_Keys().</EM></P>
<P>This effectively provides a simple and easy way of incorperating joystick and 
keyboard support into a program.</P>
<P>Example:</P>
<BLOCKQUOTE><PRE>dim x, y
x = TextCols () / 2
y = TextRows () / 2
while true
    Joy_Keys ()
    if not ScanKeyDown (VK_SPACE) then
        locate x, y: print " "
    endif
    if ScanKeyDown (VK_LEFT)    and x &gt; 0 then                  x = x - 1 endif
    if ScanKeyDown (VK_RIGHT)   and x &lt; TextCols () - 1 then    x = x + 1 endif
    if ScanKeyDown (VK_UP)      and y &gt; 0 then                  y = y - 1 endif
    if ScanKeyDown (VK_DOWN)    and y &lt; TextRows () - 1 then    y = y + 1 endif
    locate x, y: print "X"
    Sleep (30)
wend</PRE></BLOCKQUOTE>
<H3>Joy_X, Joy_Y</H3>
<P>Joy_X() returns the X (horizontal) position.<BR>Joy_Y() returns the Y 
(vertical) position.</P>
<P>Both functions return a value from -32768 (far left, or top) to 32767 (far 
right or bottom).<BR>0 is the centre of each axis. (If you have a stable, 
properly calibrated digital joystick.)</P>
<P>Example:</P>
<BLOCKQUOTE>
  <P>print Joy_X () + ", " + Joy_Y (): run</P></BLOCKQUOTE>
<H3>Joy_Button</H3>
<P>Joy_Button(<EM>index</EM>) returns true if button <EM>index</EM> is currently 
being pressed, or false if isn't.</P>
<P>The first joystick button is <EM>index</EM> 0. The second is <EM>index</EM> 1 
e.t.c</P>
<P>Example:</P>
<BLOCKQUOTE><PRE>dim i<BR>for i = 0 to 9<BR>    if joy_button (i) then print i: else print " ": endif<BR>next<BR>run</PRE></BLOCKQUOTE>
<H3>Joy_Left, Joy_Right, Joy_Up, Joy_Down</H3>
<P>Joy_Left () returns true if the joystick is more than 100 units to the left. 
(This is equivalent to: Joy_X () &lt; -100)<BR>Joy_Right () returns true if the 
joystick is more than 100 units to the right. (This is equivalent to: Joy_X () 
&gt; 100)<BR>Joy_Up () returns true if the joystick is more than 100 units 
upwards. (This is equivalent to: Joy_Y () &lt; -100)<BR>Joy_Down () returns true 
if the joystick is more than 100 units downwards. (This is equivalent to: Joy_Y 
() &gt; 100)</P>
<H3>Joy_0, ..., Joy_9</H3>
<P>There are also explicit functions for each joystick button from 0 through to 
9.</P>
<P>Joy_0() returns true if the first joystick button is being pressed. (This is 
equivalent to: Joy_Button(0)).<BR>...<BR>Joy_9() returns true if the 10th 
joystick button is being pressed. (This is equivalent to: Joy_Button(9)).</P>
<H2>Joystick polling</H2>
<P>To "poll" the joystick means to take a snapshot of it's current state, 
including the readings of the X and Y axis and whether each button is up or down 
at the time of the poll.</P>
<P>Basic4GL automatically polls the joystick whenever one of the joystick 
functions is called, so you don't have to tell it to explicitly.<BR>For 
example:</P>
<BLOCKQUOTE><PRE>while true: printr Joy_X() + " " + Joy_Y () + " " + Joy_0() + " " + Joy_1 (): wend</PRE></BLOCKQUOTE>
<P>You may want to explicitly tell Basic4GL when to poll the joystick, in order 
to make the program run faster.<BR>Polling takes time (at least on older 
analogue joysticks). It is more efficient to poll the joystick once, and then 
act on the X axis, Y axis and button data captured in that poll than to poll the 
joystick for each axis and button that you read.</P>
<H3>UpdateJoystick</H3>
<P>UpdateJoystick () polls the joystick and takes a snapshot of the X and Y axis 
and the state of all the buttons.<BR>Any Joy_? calls will now return the data 
captured at the time of the UpdateJoystick() call.<BR>For example:</P>
<BLOCKQUOTE><PRE>while true: UpdateJoystick (): printr Joy_X() + " " + Joy_Y () + " " + Joy_0() + " " + Joy_1 (): wend</PRE></BLOCKQUOTE>
<P>Now instead of reading the joystick 4 times each time around the loop, we are 
only reading it once.<BR>This runs significantly faster than the previous 
example on my PC (although my PC has an older analogue joystick attached to it.. 
I can't comment on digital joysticks.)</P>
<P>As soon as you call UpdateJoystick(), Basic4GL switches to <STRONG>explicit 
</STRONG>joystick updates, and stays that way until your program finishes 
executing. Therefore you must keep calling UpdateJoystick() at the appropriate 
times to ensure the joystick data is up to date. <BR>If you don't, the joystick 
will appear frozen, for example:</P>
<BLOCKQUOTE><PRE>UpdateJoystick ()<BR>while true: printr Joy_X() + " " + Joy_Y () + " " + Joy_0() + " " + Joy_1 (): wend</PRE></BLOCKQUOTE>
<P>Here we have moved the UpdateJoystick() call out of the main loop, so it is 
only called once at the start of the program.<BR>Because we don't ever call it 
again, each joystick functions will simply return the same value each time, i.e 
the state of the joystick at the start of the program when UpdateJoystick() was 
called.</P>
<P>So manual polling can be faster, but you must do it right!</P>
<H1>Command line</H1>
<P>Basic4GL standalone programs can accept commands from the command 
line.<BR>Command line arguments are entered after the program name when a 
program is run from the command line. For example, if we built a standalone exe 
called "CmdTest", and ran it in a command prompt window with the command:</P>
<BLOCKQUOTE><PRE>cmdtest 1 banana 2 cucumber 3 "Tomato sandwich"</PRE></BLOCKQUOTE>
<P>Then we have passed it 6 parameters:</P>
<OL>
  <LI>1 
  <LI>banana 
  <LI>2 
  <LI>cucumber 
  <LI>3 
  <LI>Tomato sandwich </LI></OL>
<P>We can access these parameters with the <EM>ArgCount</EM> and <EM>Arg</EM> 
functions.</P>
<H3>ArgCount</H3>
<P>ArgCount()<EM> </EM>returns the number of command line arguments.</P>
<H3>Arg</H3>
<P>Arg(<EM>index</EM>) returns parameter number <EM>index</EM> as a text string, 
where <EM>index</EM> is 0 to return the first parameter.<BR><EM>index 
</EM>should be between 0 and ArgCount() - 1, otherwise Arg(<EM>index</EM>) 
returns a blank string.</P>
<H2>Setting command line arguments within Basic4GL</H2>
<P>To set the command line arguments that a program will see when it is running 
inside the Basic4GL IDE, click Program-&gt;Arguments. Enter each argument on a 
separate line.</P>
<H2>Some examples</H2>
<P>Display all arguments</P>
<BLOCKQUOTE><PRE>dim i
printr ArgCount(); " argument(s) found"
for i = 0 to ArgCount() - 1
    printr Arg(i)
next</PRE></BLOCKQUOTE>
<P>Compile and run another program:</P>
<BLOCKQUOTE><PRE>dim prog
if ArgCount() = 0 then
    printr "No program name!"
    end
endif
prog = CompileFile(Arg(0), "__")
if CompilerError() &lt;&gt; "" then
    printr CompilerError()
    end
endif
Execute(prog)
if CompilerError() &lt;&gt; "" then
    print CompilerError()
    end
endif</PRE></BLOCKQUOTE>
<H1>File I/O</H1>
<H2>A note on security</H2>
<P>Basic4GL programs can only read and write files from the directory where the 
Basic4GL program was saved (or any subdirectory thereof).</P>
<P>This is for security, and is intended to protect people new to programming 
when trying out example programs from the internet and other sources. For all we 
know, the person who wrote the program might think that overwriting files in the 
Windows system directory is a hilarious practical joke. This way the potential 
damage is restricted to a small subfolder, and the people can download and run 
Basic4GL programs with confidence.</P>
<P>Obviously this means that if you distribute Basic4GL programs that use File 
I/O, you will have to ensure that the files read/written to end up in the 
appropriate directory so that they can be reached.</P>
<P><EM>Note: This security restriction applies to the general purpose File I/O 
routines described below. Other functions that load data from disk are not 
subject to these restrictions, in particular the image and texture loading 
functions can load any file they want.</EM></P>
<DIV 
style="BORDER-RIGHT: black 2px solid; PADDING-RIGHT: 8px; BORDER-TOP: black 2px solid; DISPLAY: block; PADDING-LEFT: 8px; FONT-WEIGHT: bold; PADDING-BOTTOM: 8px; BORDER-LEFT: black 2px solid; PADDING-TOP: 8px; BORDER-BOTTOM: black 2px solid; BACKGROUND-COLOR: #fff0ff">
<P>IMPORTANT:</P>
<P>As of version 2.4.12, you can switch off these safety features by unchecking 
"Safe mode" in the options screen.<BR>If you do this, then you will need to make 
sure any program you run in Basic4GL will not damage your computer. </P>
<P>Also, standalone executables created with Basic4GL ALWAYS run with "safe 
mode" switched OFF. </P></DIV>
<H2>Opening files</H2>
<H3>OpenFileRead and OpenFileWrite</H3>
<P>Files are opened like so:</P>
<P>(For writing):</P>
<BLOCKQUOTE>
  <P>dim <EM>file<BR>...</EM><BR><EM>file</EM> = OpenFileWrite 
  ("Files/<EM>filename.ext</EM>")</P></BLOCKQUOTE>
<P>(For reading):</P>
<BLOCKQUOTE>
  <P>dim <EM>file<BR>...</EM><BR><EM>file</EM> = OpenFileRead 
  ("Files/<EM>filename.ext</EM>")</P></BLOCKQUOTE>
<P>Where <EM>filename.ext</EM> is the filename and extension that is to be 
opened.</P>
<P><EM>file</EM> is an integer variable that will store the file handle. This is 
a number that Basic4GL generates to identify the file that was just opened, and 
will be passed to other file routines to read data from or write data to the 
file.</P>
<P>If a file is opened for writing, it replaces any file that was their 
previously. If no file exists, one is created.</P>
<H2>Error handling</H2>
<H3>FileError</H3>
<P>If a file I/O routine fails, the Basic4GL program simply keeps running, 
without performing the particular file operation that it attempted.</P>
<P>You can test whether the operation succeeded by calling the FileError () 
function. This is updated after every file operation. If the operation 
succeeded, it will be set to an error message, describing what went wrong.</P>
<P>For example:</P>
<BLOCKQUOTE>
  <P>dim file<BR>file = OpenFileRead ("c:\autoexec.bat")<BR>if FileError () 
  &lt;&gt; "" then print FileError (): end endif<BR>' Carry on...</P></BLOCKQUOTE>
<H2>Closing the file</H2>
<H3>CloseFile</H3>
<P>It is good practice to close the file once you've finished with it as 
follows:</P>
<BLOCKQUOTE>
  <P>CloseFile (<EM>file</EM>)</P></BLOCKQUOTE>
<P>If you forget, or your program stops for any reason before it can close the 
file, Basic4GL will close it automatically, the next time you run a Basic4GL 
program or when you close down Basic4GL.</P>
<H2>File reading routines</H2>
<P>The file must have been opened with OpenFileRead for these routines to work 
correctly.</P>
<H3>ReadLine</H3>
<P>ReadLine(<EM>file</EM>) reads a line from a text file and returns it as a 
string. The lines are separated by carriage return and/or newline 
characters.</P>
<H3>ReadText</H3>
<P>ReadText(<EM>file</EM>, <EM>skipEOL</EM>) skips over whitespace (spaces, tabs 
e.t.c) until it finds some text. It then returns all the consecutive text at 
that point until a whitespace character has been reached, as a 
string.<BR><EM>SkipEOL</EM> is a boolean (true/false) parameter. If it is true, 
then ReadText will skip over any end-of-line characters it finds in the file. If 
false, it will stop at the end-of-line and return a blank string.</P>
<P>This can be used to break up a text files into words.</P>
<H3>ReadChar</H3>
<P>ReadChar(<EM>file</EM>) reads a single character from the file and returns it 
as a string.</P>
<H3>ReadByte</H3>
<P>ReadByte(<EM>file</EM>) reads a single binary byte from the file and returns 
it as an integer.</P>
<H3>ReadWord</H3>
<P>ReadWord(<EM>file</EM>) reads a two byte "word" from the file and returns it 
as an integer.</P>
<H3>ReadInt</H3>
<P>ReadInt(<EM>file</EM>) reads a four byte integer from the file and returns it 
as an integer.</P>
<H3>ReadFloat</H3>
<P>ReadFloat(<EM>file</EM>) reads four bytes as a four byte floating point 
number and returns it as a real.</P>
<H3>ReadDouble</H3>
<P>ReadDouble(<EM>file</EM>) reads eight bytes as an eight byte floating point 
number and returns it as a real.</P>
<H3>ReadReal</H3>
<P>ReadReal(<EM>file</EM>) is a synonym for ReadFloat(<EM>file</EM>) in the 
current version of Basic4GL on the Windows platform. (Basic4GL's "real" type is 
equivalent to a "float" in C).</P>
<H2>File writing routines</H2>
<P>The file must have been opened with OpenFileWrite for these routines to work 
correctly.</P>
<H3>WriteLine</H3>
<P>WriteLine (<EM>file</EM>, <EM>text</EM>) writes <EM>text</EM> to the file and 
automatically appends a carriage return/newline pair.<BR><EM>text </EM>is a 
string value.</P>
<H3>WriteString</H3>
<P>WriteString (<EM>file</EM>, <EM>text</EM>) writes <EM>text</EM> to the file. 
No carriage return or linefeed is appended. A zero byte string terminator is 
<STRONG>NOT</STRONG> appended..<BR><EM>text </EM>is a string value.</P>
<H3>WriteChar</H3>
<P>WriteChar (<EM>file</EM>, <EM>text</EM>) writes the first character of 
<EM>text</EM> to the file as a single character.<BR><EM>text </EM>is a string 
value.</P>
<H3>WriteByte</H3>
<P>WriteByte (<EM>file</EM>, <EM>intval</EM>) writes <EM>intval</EM> to the file 
as a single byte value.<EM><BR>intval</EM> is an integer value.</P>
<H3>WriteWord</H3>
<P>WriteWord (<EM>file</EM>, <EM>intval</EM>) writes <EM>intval</EM> to the file 
as a two byte "word" value.<EM><BR>intval</EM> is an integer value.</P>
<H3>WriteInt</H3>
<P>WriteInt (<EM>file</EM>, <EM>intval</EM>) writes <EM>intval</EM> to the file 
as a four byte integer value.<EM><BR>intval</EM> is an integer value.</P>
<H3>WriteFloat </H3>
<P>WriteFloat (<EM>file</EM>, <EM>realval</EM>) writes <EM>realval</EM> to the 
file as a four byte floating point value.<EM><BR>realval</EM> is an real 
value.</P>
<H3>WriteDouble</H3>
<P>WriteDouble (<EM>file</EM>, <EM>realval</EM>) writes <EM>realval</EM> to the 
file as an eight byte floating point value.<EM><BR>realval</EM> is an real 
value.</P>
<H3>WriteReal</H3>
<P>WriteReal (<EM>file</EM>, <EM>realval</EM>) is a synonym for WriteFloat 
(<EM>file</EM>, <EM>realval</EM>)</P>
<H2>Other file I/O routines</H2>
<H3>EndOfFile</H3>
<P>EndOfFile (<EM>file</EM>) applies to files opened for reading, and returns 
true if we have reached the end of the file.</P>
<H3>Seek</H3>
<P>Seek (<EM>file, offset</EM>) applies to files opened for reading, and 
attempts to reposition the reading position to <EM>offset</EM> bytes from the 
beginining of the file.</P>
<H2>Deleting a file</H2>
<H3>DeleteFile</H3>
<P>DeleteFile(<EM>filename</EM>) will delete a file. <STRONG><EM>This routine is 
only available when "Safe mode" is switched OFF.</EM></STRONG><BR>If the delete 
succeeds, DeleteFile() returns true. Otherwise DeleteFile() returns false, and 
FileError() can be used to retrieve the text of the error.</P>
<H2>Directory listing routines</H2>
<H3>FindFirstFile</H3>
<P>FindFirstFile(<EM>mask</EM>) returns the filename of the first file that 
matches the text string<EM> mask</EM>.</P>
<P>Example:</P>
<BLOCKQUOTE><PRE>dim filename$
filename$ = FindFirstFile("*.gb")
print filename$</PRE></BLOCKQUOTE>
<P>Example 2:</P>
<BLOCKQUOTE><PRE>print FindFirstFile("files\*.*")</PRE></BLOCKQUOTE>
<P>Directory listing is subject to the same restrictions as general file access. 
That is, the directory must be the same directory as where the Basic4GL program 
is saved, or a subdirectory.</P>
<P>If no matching file is found, "FindFirstFile" returns an empty string 
("").</P>
<H3>FindNextFile</H3>
<P>FindNextFile() returns the filename of the next matching file in the 
directory.<BR>This function uses the same mask as was passed to "FindFirstFile", 
and therefore will only work after a successful "FindFirstFile" call.</P>
<P>"FindNextFile" will keep returning the next filename until there are no more 
matching files, at which point it returns an empty string ("").</P>
<P>Example:</P>
<BLOCKQUOTE><PRE>dim filename$
filename$ = FindFirstFile("*.gb")
while filename$ &lt;&gt; ""
    printr filename$
    filename$ = FindNextFile()
wend
FindClose()</PRE></BLOCKQUOTE>
<H3>FindClose</H3>
<P>FindClose() will free resources after a FindFirstFile..FindNextFile directory 
search.</P>
<P>It is not strictly required as Basic4GL will do this for you automatically 
when the program finishes. However it is good practice.</P>
<H1>Sound</H1>
<P>Basic4GL uses the Audiere sound library, which supports a number of different 
sound formats such as .wav, streamed music formats such as Ogg Vorbis, and "mod" 
formats like .mod, .s3m, .xm and .it. See the <A 
href="http://audiere.sourceforge.net/">Audiere home page</A> for more 
information.</P>
<H2>Standalone exe distribution</H2>
<P>If you use sound or music functions in your program, and you wish to 
distribute it as a standalone executable (see <A 
href="Creating%20Standalone%20Exes.htm">Creating Standalone Exes</A>) be aware 
that you must also distribute:</P>
<UL>
  <LI>audiere.dll 
  <LI>b4glsound.dll </LI></UL>
<P>which must be placed in the same folder as your standalone .exe file. 
Otherwise your program will run silently.</P>
<P>You can test whether the Basic4GL sound engine has initialised correctly by 
placing the following code at the top of your program.</P>
<BLOCKQUOTE><PRE>if SoundError() &lt;&gt; "" then
    print SoundError()
    end
endif</PRE></BLOCKQUOTE>
<P>If the sound engine has <STRONG>not</STRONG> initialised correctly (because 
either of the dlls could not be loaded), it will print the message:</P>
<BLOCKQUOTE>
  <P><EM>Sound playback requires Audiere.dll and B4GLSound.dll to be placed in 
  the same folder</EM></P></BLOCKQUOTE>
<P>and stop.</P>
<H2>Sound functions</H2>
<H3>LoadSound</H3>
<P>Sounds are loaded as follows:</P>
<BLOCKQUOTE>
  <P>dim <EM>sound</EM><BR>...<BR><EM>sound</EM> = LoadSound 
  (<EM>filename</EM>)</P></BLOCKQUOTE>
<P><EM>Filename</EM> must refer to a file of a supported sound format.</P>
<H3>PlaySound</H3>
<P>Once the sound has been loaded, it can be played as follows:</P>
<BLOCKQUOTE>
  <P>PlaySound (<EM>sound</EM>)</P></BLOCKQUOTE>
<P>or</P>
<BLOCKQUOTE>
  <P>PlaySound(<EM>sound, volume, looped</EM>)</P></BLOCKQUOTE>
<P>Here <EM>sound</EM> is the sound handle that was returned from 
LoadSound(...).<BR><EM>Volume</EM> is the sound volume, where 1 = full volume, 
0.5 = half volume etc. (You can also use values greater than 1, but be warned 
that the sound may "clip" and become distorted.)<BR>Setting <EM>looped</EM> to 
true will cause the sound to play continuously in a loop.</P>
<P>Note: If <EM>volume</EM> and <EM>looped</EM> are not specified they default 
to <EM>volume</EM> = 1 and <EM>looped</EM> = false.</P>
<P>PlaySound(...) returns the number of the "voice" that was chosen to play the 
sound. Basic4GL supports 10 voices, which defines the maximum number of sounds 
that can be played simultaneously.<BR>This number is useful if you want to stop 
the sound later (especially for looped sounds like footsteps), as you can pass 
it to the StopSoundVoice(...) function.</P>
<H3>DeleteSound</H3>
<P>DeleteSound (<EM>sound</EM>) deletes the sound from memory.<BR>If you don't 
explicitly delete them, Basic4GL will automatically do so when your program 
finishes.</P>
<H3>StopSoundVoice</H3>
<P>To stop a sound playing, use:</P>
<BLOCKQUOTE>
  <P>StopSoundVoice(<EM>voice</EM>)</P></BLOCKQUOTE>
<P><EM>Voice</EM> is the number of the voice you wish to stop playing.<BR>This 
number is returned from PlaySound(...) when the sound was started.</P>
<H3>StopSounds</H3>
<P>You can also stop all sounds with:</P>
<BLOCKQUOTE>
  <P>StopSounds()</P></BLOCKQUOTE>
<H2>Music functions</H2>
<P>These functions are used to stream in and play music files, such as Ogg 
Vorbis, or "mod" files (.mod, .s3m, .xm, .it etc).</P>
<H3>PlayMusic</H3>
<P>Start playing a music file with:</P>
<BLOCKQUOTE>
  <P>PlayMusic(<EM>filename</EM>)</P></BLOCKQUOTE>
<P>or</P>
<BLOCKQUOTE>
  <P>PlayMusic(<EM>filename</EM>, <EM>volume</EM>, 
<EM>looped</EM>)</P></BLOCKQUOTE>
<P><EM>Filename</EM> must be a file of a supported music format. <EM>Volume</EM> 
and <EM>looped</EM> behave the same as with PlaySound(...).</P>
<P>This will open the file and start playing it immediately.<BR>Unlike regular 
sound files music files are "streamed". This means that the file is not loaded 
into memory all at once. Instead the file is loaded in continuously while the 
music is playing.<BR>Basic4GL supports playing one music file at a time only. If 
a music file is already playing, it will stop and the new file will play 
instead.</P>
<P>Example:</P>
<BLOCKQUOTE><PRE>dim filename$
printr"Filename:": input filename$
PlayMusic(filename$)
if SoundError() &lt;&gt; "" then printr SoundError(): end endif
while MusicPlaying(): Sleep(100): wend</PRE></BLOCKQUOTE>
<H3>StopMusic</H3>
<P>StopMusic() will stop music file from playing.</P>
<H3>MusicPlaying</H3>
<P>MusicPlaying() returns true while the music file is playing.</P>
<H3>SetMusicVolume</H3>
<P>To set the music volume while music is playing, use:</P>
<BLOCKQUOTE>
  <P>SetMusicVolume(<EM>volume</EM>)</P></BLOCKQUOTE>
<P>Where <EM>volume</EM> behaves the same as with PlaySound() or 
PlayMusic().</P>
<H2>Sound and music errors</H2>
<P>If a sound or music function fails, Basic4GL will store a description of the 
error, which can be retrieved with the SoundError() function.</P>
<H3>SoundError</H3>
<P>SoundError() returns a text string describing the result of the last sound or 
music function call.</P>
<P>If the call was successful, SoundError() returns the empty string (""). 
Otherwise it returns the text of the error message.</P>
<P>Example:</P>
<BLOCKQUOTE><PRE>dim sound, i
sound = LoadSound("c:\windows\media\chimes.wav")
if SoundError() &lt;&gt; "" then 
    printr SoundError()
else
    PlaySound(sound)
    Sleep(2000)
endif</PRE></BLOCKQUOTE>
<H1>General purpose functions</H1>
<P>These functions are used for general purpose operations, such as mathematics 
equations and string manipulation.</P>
<H3>abs</H3>
<P>Abs(<EM>x</EM>) returns the absolute value of <EM>x</EM>.</P>
<H3>arraymax</H3>
<P>ArrayMax(<EM>array</EM>) returns the index of the highest element of 
<EM>array</EM>. Iterating elements 0..ArrayMax(<EM>array</EM>) will therefore 
visit every element inside the array.<BR>ArrayMax is a special function in that 
<EM>array</EM> can be any type, so long as it is an array.</P>
<H3>asc</H3>
<P>Asc(<EM>x</EM>) takes a single string parameter <EM>x</EM>, and returns the 
ASCII value of the first character.<BR>This is the opposite of the chr$ 
function</P>
<H3>atn</H3>
<P>Atn(<EM>x</EM>) returns the Arc Tangent value of <EM>x</EM>, in radians.</P>
<H3>
<H3>atnd</H3></H3>
<P>Atnd(<EM>x</EM>) returns the Arc Tangent value of <EM>x</EM>, in degrees.</P>
<H3>atn2</H3>
<P>Atn2(x, y) returns the Arc Tangent value of <EM>x</EM>, <EM>y,</EM> in 
radians.</P>
<H3>
<H3>atn2d</H3></H3>
<P>Atn2(x, y) returns the Arc Tangent value of <EM>x</EM>, <EM>y,</EM> in 
degrees.</P>
<H3>beep</H3>
<P>Beep() causes the computer to beep.</P>
<H3>chr$</H3>
<P>Chr$(<EM>x</EM>) takes a single integer parameter <EM>x</EM>, and returns a 
string character whose ASCII value is <EM>x</EM>.</P>
<P>Example:</P>
<BLOCKQUOTE>
  <P>Printr Chr$(72)+Chr$(101)+Chr$(108)+Chr$(108)+Chr$(111)</P></BLOCKQUOTE>
<H3>cos</H3>
<P>Cos(<EM>x</EM>) returns the Cosine of <EM>x</EM>, where <EM>x</EM> is 
measured in radians.</P>
<H3>cosd</H3>
<P>Cosd(<EM>x</EM>) returns the Cosine of <EM>x</EM>, where <EM>x</EM> is 
measured in degrees.</P>
<H3>exp</H3>
<P>Exp(<EM>x</EM>) returns e raised to the power of <EM>x</EM>.</P>
<P>Exp is the inverse of Log.</P>
<H3>int</H3>
<P>Int(<EM>x</EM>) casts a real valued <EM>x</EM> to an integer.<BR>The rounding 
is slightly different to the implicit type cast when a real value is assigned to 
an integer.<BR>Int(<EM>x</EM>) rounds <EM>x</EM> towards negative infinity, 
whereas implicit type casting always rounds towards 0.</P>
<P>Example:</P>
<BLOCKQUOTE>
  <P>dim a#, i1, i2: a# = -5.1<BR>i1 = a#<BR>i2 = Int(a#)<BR>printr "i1 = " + 
  i1<BR>printr "i2 = " + i2</P></BLOCKQUOTE>
<H3>left$</H3>
<P>Left$(<EM>s</EM>,<EM>c</EM>) returns a string containing the first <EM>c</EM> 
characters of <EM>s</EM>.<EM><BR>s</EM> is a string value, <EM>c</EM> is an 
integer value.</P>
<P>For example, Left$("ABCDEFG", 3) returns "ABC"</P>
<H3>lcase$</H3>
<P>LCase$ (<EM>x</EM>) returns <EM>x</EM> converted to lowercase.</P>
<H3>len</H3>
<P>Len(<EM>x</EM>) returns the length of the string <EM>x</EM> in 
characters.</P>
<H3>log</H3>
<P>Log(<EM>x</EM>) returns the natural logarithm of <EM>x</EM>.</P>
<P>Log is the inverse of Exp.</P>
<H3>mid$</H3>
<P>Mid$(<EM>s</EM>,<EM>i</EM>,<EM>c</EM>) returns a string containing <EM>c</EM> 
consecutive characters of string <EM>s</EM>, starting from the <EM>i</EM>th 
character.</P>
<P>For example, Mid$("ABCDEFG", 4, 3) returns "DEF".</P>
<H3>performancecounter</H3>
<P>PerformanceCounter() returns the number of milliseconds that have elapsed 
since the computer was turned on.<BR>This function is very similar to 
TickCount(), except PerformanceCounter() is accurate to1 millisecond whereas 
TickCount() is only accurate to 10ms.</P>
<P>Therefore I strongly recommend using PerformanceCounter() for any timing 
operations.</P>
<P>The old TickCount() function is retained only for backwards compatibility 
with existing Basic4GL programs.</P>
<H3>pow</H3>
<P>Pow(<EM>x</EM>,<EM>y</EM>) returns <EM>x</EM> raised to the power of 
<EM>y</EM>.</P>
<H3>right$</H3>
<P>Right$(<EM>s</EM>,<EM>c</EM>) returns a string containing the last <EM>c</EM> 
characters of <EM>s</EM>.</P>
<P>For example, Right$("ABCDEFG", 3) returns "EFG"</P>
<H3>rnd</H3>
<P>Rnd() returns a random integer value, between 0 and RND_MAX.<BR>(RND_MAX = 
32767, but could be different in future ports of Basic4GL to different platforms 
or operating systems.)</P>
<P>To return a random number between 0 and <EM>x-1 </EM>(inclusive), use:</P>
<BLOCKQUOTE>
  <P>Rnd() % <EM>x</EM></P></BLOCKQUOTE>
<P>To return a random number between 1 and <EM>x</EM> (inclusive), use:</P>
<BLOCKQUOTE>
  <P>Rnd() % <EM>x</EM> + 1</P></BLOCKQUOTE>
<H3>sgn</H3>
<P>Sgn(<EM>x</EM>) returns:</P>
<P>1, if <EM>x</EM> is greater than 0<BR>0, if <EM>x</EM> equals 0<BR>-1, if 
<EM>x</EM> is less than 0</P>
<H3>sin</H3>
<P>Sin(<EM>x</EM>) returns the Sine of <EM>x</EM>, where <EM>x</EM> is measured 
in radians.</P>
<H3>sind</H3>
<P>Sind(<EM>x</EM>) returns the Sine of <EM>x</EM>, where <EM>x</EM> is measured 
in degrees.</P>
<H3>sqr</H3>
<P>Sqr(<EM>x</EM>) returns the square root of <EM>x</EM>.</P>
<P>(Actually the square root of the absolute value of <EM>x</EM>.)</P>
<H3>sqrt</H3>
<P>Sqrt(<EM>x</EM>) is exactly the same as Sqr(<EM>x</EM>)</P>
<H3>str$</H3>
<P>Str$(<EM>x</EM>) converts an integer value <EM>x</EM> into a string 
representation of <EM>x</EM>.</P>
<P>For example, Str$(-13.4) returns "-13.4".</P>
<H3>tan</H3>
<P>Tan(<EM>x</EM>) returns the Tangent of <EM>x</EM>, where <EM>x</EM> is 
measured in radians.</P>
<H3>tand</H3>
<P>Tand(<EM>x</EM>) returns the Tangent of <EM>x</EM>, where <EM>x</EM> is 
measured in degrees.</P>
<H3>tanh</H3>
<P>Tanh(<EM>x</EM>) returns the Hyperbolic Tangent of <EM>x</EM>, where 
<EM>x</EM> is measured in radians.</P>
<H3>tickcount</H3>
<P>TickCount() returns the number of milliseconds that have elapsed since the 
computer was turned on.<BR>Note: This function is only accurate to about 10ms. I 
strongly advise using PerformanceCounter() instead.</P>
<H3>ucase$</H3>
<P>UCase$ (<EM>x</EM>) returns <EM>x</EM> converted to uppercase.</P>
<H3>val</H3>
<P>Val(<EM>x</EM>) converts a string <EM>x</EM> into a numeric value.<BR>If 
<EM>x</EM> cannot be converted into a number, then Val(<EM>x</EM>) returns 
0.</P>
<P>For example, Val("27.2") returns 27.2.</P>
<P>Val is the opposite of Str$.</P>
<H1>Vector and Matrix routines</H1>
<P>Basic4GL contains built in support for matrix and vector arithmetic, through 
a library of trigonometry functions, and also through extensions to standard 
mathematical operators (+, -, * e.t.c) to work with vector and matrix types.</P>
<H2>Vector storage format</H2>
<P>Vectors are stored as an array of reals. For example:</P>
<BLOCKQUOTE>
  <P>dim vec#(3)<BR>vec# = vec4 (1, 2, 3, 1) ' Create a vector and assign it to 
  vec#</P></BLOCKQUOTE>
<P>To be elegible for use with the built in trigonometry functions, the array 
must have 2, 3 or 4 elements. (Remember that declaring an array as size 3 
actually results in <EM>4</EM> elements, 0 through 3 inclusive).</P>
<P>Element 0 stores the <EM>x</EM> component, element 1 stores <EM>y</EM> 
component, 2 stores <EM>z</EM> and 3 stores <EM>w</EM>.</P>
<P>Certain trigonometry functions that operate on 4 component vectors will 
automatically substitue <EM>z</EM> = 0 and/or <EM>w</EM> = 1 when short version 
vectors are passed in.</P>
<H2>Matrix storage format</H2>
<P>A matrix is a 4 x 4 array of reals, and must always be "DIM"med as:</P>
<BLOCKQUOTE>
  <P><EM>matrixname</EM>#(3)(3)</P></BLOCKQUOTE>
<P>Example:</P>
<BLOCKQUOTE><PRE>dim matrix#(3)(3)<BR>matrix# = IdentityMatrix () ' Assign a matrix to matrix#</PRE></BLOCKQUOTE>
<P>The first array dimension corresponds to the <EM>x</EM> coordinate of the 
matrix, and the second to the <EM>y</EM>.</P>
<P>Basic4GL vector and matrix storage format and operations are designed to 
mirror those of OpenGL.<BR>As such vectors are multiplied as column vectors on 
the right hand side of matrices. Matrices are stored as an array of column 
vectors.</P>
<H2>Creating vectors</H2>
<P>Vectors are just arrays, so you can read from and write to them like any 
other array.</P>
<BLOCKQUOTE><PRE>dim v#(3), i<BR>for i = 0 to 3: v#(i) = i: next ' Create a (0 1 2 3) vector</PRE></BLOCKQUOTE>
<BLOCKQUOTE><PRE>dim v1#(3), v2#(3), dotProd#<BR>dotProd# = v1#(0)*v2#(0) + v1#(1)*v2#(1) + v1#(2)*v2#(2)<BR>' Calculate the vector dot product<BR>' (Note: we could also have said dotProd# = v1# * v2#)</PRE></BLOCKQUOTE>
<P>However there are a set of routines for creating vectors quickly and 
simply:</P>
<H3>vec4, vec3 and vec2</H3>
<P>vec4(<EM>x</EM>, <EM>y</EM>, <EM>z</EM>, <EM>w</EM>) returns a 4 component 
vector with <EM>x, y, z </EM>and <EM>w</EM> components initialised 
accordingly.</P>
<P>vec3(<EM>x</EM>, <EM>y</EM>, <EM>z</EM>) returns a 3 component vector with 
<EM>x, y </EM>and <EM>z</EM> components initialised accordingly.</P>
<P>vec2(<EM>x</EM>, <EM>y</EM>) returns a 2 component vector with <EM>x</EM> and 
<EM>y</EM> components initialised accordingly.</P>
<P>Examples:</P>
<BLOCKQUOTE><PRE>dim lightsource#(3)<BR>lightsource# = vec4(0, 100, 0, 1) ' Lightsource at (0 100 0)</PRE></BLOCKQUOTE>
<P>This is exactly equivalent to:</P>
<BLOCKQUOTE><PRE>dim lightsource#(3)<BR>lightsource#(0) = 0<BR>lightsource#(1) = 100<BR>lightsource#(2) = 0<BR>lightsource#(3) = 1</PRE></BLOCKQUOTE>
<P>The first version is simply a more compact alternative.</P>
<H2>Extended mathematics operators</H2>
<P>Certain mathematics operators have been extended to accept vectors and or 
matrices as input, and (where appropriate) return a vector or a matrix as a 
result.</P>
<P><EM>vec</EM> = A vector<BR><EM>matrix</EM> = A matrix<BR><EM>real</EM> = A 
real value</P>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD><STRONG><U>Expression</U></STRONG></TD>
    <TD><STRONG><U>Result</U></STRONG></TD></TR>
  <TR>
    <TD>-<EM>vec</EM></TD>
    <TD>Returns <EM>vec</EM> negated. That is <EM>vec</EM> scaled by -1</TD></TR>
  <TR>
    <TD width="25%">-<EM>matrix</EM></TD>
    <TD>Returns <EM>matrix </EM>negated. I.e <EM>matrix</EM> scaled by 
-1</TD></TR>
  <TR>
    <TD><EM>vec</EM> * <EM>real<BR></EM>or<BR><EM>real</EM> * <EM>vec</EM></TD>
    <TD>Returns <EM>vector</EM> scaled by <EM>real</EM></TD></TR>
  <TR>
    <TD><EM>matrix</EM> * <EM>real</EM><BR>or<BR><EM>real</EM> *<EM> 
      matrix</EM></TD>
    <TD>Returns <EM>matrix</EM> scaled by <EM>real</EM></TD></TR>
  <TR>
    <TD><EM>matrix</EM> * <EM>vec</EM></TD>
    <TD>Returns <EM>vec</EM> multiplied as a column vector on the right hand 
      side of <EM>matrix</EM>. The result is another vector.</TD></TR>
  <TR>
    <TD><EM>matrix1</EM> * <EM>matrix2</EM></TD>
    <TD>Returns <EM>matrix2</EM> multiplied on the right hand side of 
      <EM>matrix1.</EM> The result is another matrix.</TD></TR>
  <TR>
    <TD><EM>vec1</EM> * <EM>vec2</EM></TD>
    <TD>Returns the dot product of <EM>vec1 </EM>and <EM>vec2</EM>, as a real 
      value.</TD></TR>
  <TR>
    <TD><EM>vec </EM>/ <EM>real</EM></TD>
    <TD>Returns <EM>vec</EM> scaled by 1 / <EM>real</EM></TD></TR>
  <TR>
    <TD><EM>matrix</EM> / <EM>real</EM></TD>
    <TD>Returns <EM>matrix </EM>scaled by 1 / <EM>real</EM></TD></TR>
  <TR>
    <TD><EM>vec1</EM> + <EM>vec2</EM></TD>
    <TD>Returns <EM>vec2</EM> added to <EM>vec1</EM> as a vector</TD></TR>
  <TR>
    <TD><EM>matrix1 </EM>+ <EM>matrix2</EM></TD>
    <TD>Returns <EM>matrix2 </EM>added to <EM>matrix1</EM> as matrix</TD></TR>
  <TR>
    <TD><EM>vec1</EM> - <EM>vec2</EM></TD>
    <TD>Returns <EM>vec2</EM> subtracted from <EM>vec1</EM> as a vector</TD></TR>
  <TR>
    <TD><EM>matrix1 </EM>- <EM>matrix2</EM></TD>
    <TD>Returns <EM>matrix2 </EM>subtracted from <EM>matrix1</EM> as a 
    matrix</TD></TR></TBODY></TABLE>
<H2>Matrix creation functions</H2>
<P>These are based on the OpenGL matrix functions (glTranslate-, glRotate-, 
e.t.c).</P>
<H3>MatrixZero</H3>
<P>MatrixZero () returns a matrix where every element is zero.</P>
<BLOCKQUOTE><PRE>dim m#(3)(3)<BR>m# = MatrixZero ()</PRE></BLOCKQUOTE>
<H3>MatrixIdentity</H3>
<P>MatrixIdentity () returns the identity matrix.</P>
<H3>MatrixScale</H3>
<P>MatrixScale (<EM>scale</EM>) returns a scale matrix</P>
<H3>MatrixTranslate</H3>
<P>MatrixTranslate (<EM>x</EM>, <EM>y</EM>, <EM>z</EM>) returns a translation 
matrix.</P>
<H3>MatrixRotateX, MatrixRotateY and MatrixRotateZ</H3>
<P>MatrixRotateX (<EM>angle</EM>) returns a matrix that rotates anticlockwise 
around the positive X axis by <EM>angle</EM> degrees.</P>
<P>Likewise MatrixRotateY (<EM>angle</EM>) and MatrixRotateZ (<EM>angle</EM>) 
return matrices that rotate around their respective axes.</P>
<P>There is no function for creating a rotation matrix around an arbitrary axis 
(like glRotate- in OpenGL) because I'm not smart enough! :-) (If anyone wants to 
send me the maths, I'll add one...)</P>
<H3>MatrixBasis</H3>
<P>MatrixBasis (<EM>vecx</EM>, <EM>vecy</EM>, <EM>vecz</EM>) creates a matrix 
from 3 basis vectors.</P>
<H3>MatrixCrossProduct</H3>
<P><FONT color=#000000>MatrixCrossProduct (<EM>vec</EM>) creates a cross product 
matrix for <EM>vec</EM>. This matrix has the property that when multiplied with 
a vector <EM>v</EM>, the result is <EM>vec</EM></FONT> x <EM>v</EM>. That is the 
cross product of <EM>vec</EM> and <EM>v</EM>.</P>
<H2>Using Matrices with OpenGL</H2>
<H3>glLoadMatrixf, glMultMatrixf</H3>
<P>You can copy a standard matrix into OpenGL, replacing the perspective, 
model-view or texture matrix (whatever was last selected by glMatrixMode 
()).<BR>You can also multiply the current OpenGL matrix with a standard 
matrix.<BR>The new matrix will transform vertices passed to OpenGL (or texture 
coordinates for the texture matrix), just as if you had built the matrix with 
glRotate-, glTranslate-, glScale-,... commands.</P>
<P><STRONG>glLoadMatrixf </STRONG>(<EM>matrix</EM>) will replace the current 
OpenGL matrix with <EM>matrix</EM>.</P>
<P><STRONG>glMultMatrixf</STRONG> (<EM>matrix</EM>) will multiply the current 
OpenGL matrix by <EM>matrix</EM>. The resulting matrix replaces the previous 
OpenGL matrix.</P>
<P><EM>(Note: glLoadMatrixd and glMultMatrixd also work. However as Basic4GL 
works with floats internally rather than doubles, there is no particular 
advantage in using these functions.)</EM></P>
<P>Examples:<BR>The following examples all draw a square 10 units "into the 
screen", rotated anticlockwise by 20 degrees.</P>
<P>1.</P>
<BLOCKQUOTE><PRE>' Standard OpenGL matrix routines<BR>glLoadIdentity ()<BR>glTranslatef (0, 0, -10)<BR>glRotatef (20, 0, 0, 1)<BR>    glBegin (GL_QUADS)<BR>glVertex2f (-1, 1): glVertex2f (-1, -1): glVertex2f (1, -1): glVertex2f (1, 1)<BR>glEnd ()</PRE></BLOCKQUOTE>
<P>2.</P>
<BLOCKQUOTE><PRE>' Using glMultMatrixf to multiply in basic matrices<BR>glLoadMatrixf (MatrixIdentity ())<BR>glMultMatrixf (MatrixTranslate (0, 0, -10))<BR>glMultMatrixf (MatrixRotateZ (20))<BR>glBegin (GL_QUADS)<BR>    glVertex2f (-1, 1): glVertex2f (-1, -1): glVertex2f (1, -1): glVertex2f (1, 1)<BR>glEnd ()</PRE></BLOCKQUOTE>
<P>3.</P>
<BLOCKQUOTE><PRE>' Build a complete matrix and load into OpenGL in one go<BR>glLoadMatrixf (MatrixTranslate (0, 0, -10) * MatrixRotateZ (20))<BR>glBegin (GL_QUADS)<BR>    glVertex2f (-1, 1): glVertex2f (-1, -1): glVertex2f (1, -1): glVertex2f (1, 1)<BR>glEnd ()</PRE></BLOCKQUOTE>
<P>4.</P>
<BLOCKQUOTE><PRE>' Matrix stored in a variable<BR>dim m#(3)(3)<BR>m# = MatrixTranslate (0, 0, -10) * MatrixRotateZ (20)<BR>glLoadMatrixf (m#)<BR>glBegin (GL_QUADS)<BR>    glVertex2f (-1, 1): glVertex2f (-1, -1): glVertex2f (1, -1): glVertex2f (1, 1)<BR>glEnd ()</PRE></BLOCKQUOTE>
<P>Alternatively we could simply transform the vertices before passing them to 
OpenGL</P>
<BLOCKQUOTE><PRE>dim m#(3)(3)<BR>m# = MatrixTranslate (0, 0, -10) * MatrixRotateZ (20)<BR>glBegin (GL_QUADS)<BR>    glVertex3fv (m# * vec3(-1, 1, 0))<BR>    glVertex3fv (m# * vec3(-1, -1, 0))<BR>    glVertex3fv (m# * vec3(1, -1, 0))<BR>    glVertex3fv (m# * vec3(1, 1, 0))<BR>glEnd ()</PRE></BLOCKQUOTE>
<P>Which works just as well.<BR>However, keep in mind that if we perform the 
transformations ourselves we deny OpenGL the opportunity to perform the 
transformations, and make use of any optimisations such as hardware 
transformations supported on modern 3D graphics cards.</P>
<H2>Other trigonometry functions</H2>
<H3>CrossProduct</H3>
<P>CrossProduct (<EM>vec1</EM>, <EM>vec2</EM>) returns the vector cross product 
of <EM>vec1</EM> and <EM>vec2</EM>. The result is a vector.</P>
<H3>Length</H3>
<P>Length (<EM>vec</EM>) returns the length of <EM>vec</EM>.<BR>This is 
equivalent to sqr(<EM>vec</EM>*<EM>vec</EM>)</P>
<H3>Normalize</H3>
<P>Normalize (<EM>vec</EM>) returns <EM>vec</EM> scaled to length 1.<BR>This is 
equivalent to <EM>vec</EM> / Length(<EM>vec</EM>)</P>
<H3>Determinant</H3>
<P>Determinant (<EM>matrix</EM>) returns the matrix determinant of 
<EM>matrix</EM>. The result is a real value.</P>
<H3>Transpose</H3>
<P>Transpose (<EM>matrix</EM>) returns <EM>matrix</EM> transposed. (That is 
<EM>matrix</EM> mirrored about the diagonal.)</P>
<H3>RTInvert</H3>
<P>RTInvert (<EM>matrix</EM>) returns <EM>matrix</EM> inverted, for any 
<EM>matrix</EM> containing only rotations and translations.<BR>If 
<EM>matrix</EM> contains any other transformations apart from rotations and 
translations then the result is undefined, and will <STRONG>not</STRONG> be the 
inverse of <EM>matrix.</EM></P>
<H3>Orthonormalize</H3>
<P>Orthonormalize (<EM>matrix</EM>) returns an orthonormal matrix by performing 
a series of normalizations and cross products on the basis vectors of 
<EM>matrix.</EM></P>
<P>This is useful for matrices that are nearly orthonormal. For example to 
ensure a matrix (that should be orthonormal) hasn't accumulated rounding errors 
after a large number of transformations.</P>
<H2>Handling the w coordinate</H2>
<P>Some of the above functions (such as CrossProduct) and operators (such as +) 
take two vectors and return a single result vector. Basic4GL sets the <EM>w</EM> 
coordinate of the resulting vector as follows:</P>
<UL>
  <LI>If <EM>w</EM> = 0 for both input vectors, then <EM>w</EM> = 0 for the 
  resulting vector 
  <LI>Otherwise <EM>w</EM> is set to 1 </LI></UL>
<P>If this is not the behaviour that you want, you will have to set the 
<EM>w</EM> coordinate manually.</P>
<P>There is no special treatment of <EM>w</EM> when multiplying a vector by a 
matrix, <EM>w</EM> is calculated like any other component. You will need to 
divide through by <EM>w</EM> manually if this is the behaviour you require.</P>
<BLOCKQUOTE><PRE>dim vec#(3), matrix#(3)(3)</PRE><PRE>...</PRE><PRE>vec# = matrix# * vec#		' Multiply vector by matrix
vec# = vec# / vec#(3)		' Divide through by w</PRE></BLOCKQUOTE>
<H1>Runtime compilation</H1>
<DIV 
style="BORDER-RIGHT: black 2px solid; PADDING-RIGHT: 8px; BORDER-TOP: black 2px solid; DISPLAY: block; PADDING-LEFT: 8px; FONT-WEIGHT: bold; PADDING-BOTTOM: 8px; BORDER-LEFT: black 2px solid; PADDING-TOP: 8px; BORDER-BOTTOM: black 2px solid; BACKGROUND-COLOR: #fff0ff">
<P>IMPORTANT:</P>
<P>As of version 2.5.1 the following functions are deprecated. If at all 
possible you should use the "comp" and "exec" commands that are documented in 
the language guide (as they are now built in language commands).</P>
<P>These old functions are still available for backwards compatibility with 
older Basic4GL programs. However they cannot be used in combination with user 
functions and subs, and you will get a runtime error if you try to do so.</P>
<P>The exception is the following functions: CompilerError, CompilerErrorLine 
and CompilerErrorCol.</P>
<P>These are still considered current, and can be used with the new "comp" 
command.</P></DIV>
<P>The following functions can be used to compile and execute code at 
runtime.</P>
<H3>Compile</H3>
<P>Compile(<EM>text</EM>) compiles <EM>text</EM> into program code, and returns 
an integer that identifies the compiled code.</P>
<P>Example:</P>
<BLOCKQUOTE><PRE>dim code
code = Compile("printr " + chr$(34) + "Hello world" + chr$(34))
Execute(code)</PRE></BLOCKQUOTE>
<P><EM>Text</EM> can either be a string, or an array of strings.<BR>If the text 
compiles successfully, "Compile" returns an integer handle that can be passed to 
the "Execute" function.<BR>If the text does not compile, "Compile" returns 0, 
and the error description and position can be extracted using the CompilerError, 
CompilerErrorLine and CompilerErrorCol functions.</P>
<H3>CompileFile</H3>
<P>CompileFile(<EM>filename</EM>) loads a file from disk, compiles it, and 
returns an integer that identifies the compiled code.</P>
<P>Example:</P>
<BLOCKQUOTE><PRE>dim code
code = CompileFile("md2viewer.gb")
if code = 0 lor not Execute(code) then
    printr CompilerError()
endif</PRE></BLOCKQUOTE>
<P>Important:</P>
<P>CompileFile can compile just about any program that can be loaded into 
Basic4GL and compiled manually. However there are some limitations:</P>
<UL>
  <LI>CompileFile does not support includes. 
  <LI>CompileFile does not support plugins.</LI></UL>
<H3>Execute</H3>
<P>Execute(<EM>handle</EM>) executes a block of compiled 
code.<BR><EM>handle</EM> must be a valid handle returned from a successful 
"Compile" or "CompileFile".</P>
<P>If the code completes without any errors, "Execute" returns true. Otherwise 
"execute" returns false, and the error message can be read using the 
"CompilerError", "CompilerErrorLine" and "CompilerErrorCol" functions.</P>
<P>The compiled code will execute until one of the following occurs:</P>
<UL>
  <LI>The end of the code is reached. 
  <LI>An "end" instruction is reached. 
  <LI>A "run" instruction is reached (this is considered a run-time error in 
  dynamically compiled code). 
  <LI>A runtime error occurs. </LI></UL>
<P>The program will then continue executing from the next instruction after the 
"Execute" call.</P>
<H2>Compiling with a "symbol prefix"</H2>
<P>These special versions of the above functions can be used to compile code 
with an automatic "symbol prefix":</P>
<UL>
  <LI>Compile(<EM>text</EM>, <EM>symbol prefix</EM>) 
  <LI>CompileFile(<EM>filename</EM>, <EM>symbol prefix</EM>) </LI></UL>
<P>The <EM>symbol prefix</EM> is a text string that is automatically prefixed to 
the front of every variable name, label name or structure name that the runtime 
compiled program refers to.</P>
<P>For example:</P>
<BLOCKQUOTE><PRE>dim text$, program, i, __value
text$ = "value = value * value"
program = Compile(text$, "__")  
printr CompilerError()

for i = 1 to 10
    __value = i
    execute(program)
    printr i + ", " + __value
next</PRE></BLOCKQUOTE>
<P>Here our code to compile at runtime is "value = value * value". But because 
we pass a <EM>symbol prefix</EM> of "__" (double underscore) to the Compile() 
command, what <EM>actually</EM> gets compiled is "__value = __value * 
__value".</P>
<P>The important thing here is that the runtime code <EM>cannot access</EM> any 
of the main program's variables except those that we have prefixed with "__". It 
cannot access "i" for example, as "i = 5" would effectively be compiled as "__i 
= 5".</P>
<P>We can use this to limit exactly which variables, labels and structure types 
the runtime compiled program has access to.</P>
<H3>CompilerError, CompilerErrorLine, CompilerErrorCol</H3>
<P>CompilerError() returns the error message generated by the last "Compile", 
"CompileFile" or "Execute" call. If there was no error (i.e. the call was 
successful), "CompilerError" returns an empty string ("").</P>
<P>CompilerErrorLine() and CompilerErrorCol() return the line and column of the 
last error (if applicable). <BR>For a "Compile" or "CompileFile" call, this is 
the position of the error in the code being compiled.<BR>For an "Execute" call, 
this is the instruction that caused the run-time error.</P>
<H2><FONT color=#000000>Runtime compilation issues</FONT></H2>
<P><FONT color=#000000>There are a some potential issues with runtime compiled 
code that need to be kept in mind.<BR>It is tempting to think that runtime 
compiled code is crash-proof, because any runtime errors immediately return 
control to the calling program which can deal with the error 
appropriately.<BR>This is true. However the runtime compiled code has access to 
everything in the parent program (by default, although this can be controlled by 
"symbol prefixes" - see above), including all variables, labels etc, and can 
often mess things up enough that the program will not run correctly when control 
is returned.</FONT></P>
<P><FONT color=#000000>For example,the following program:</FONT></P>
<BLOCKQUOTE><PRE><FONT color=#000000>dim text$, code
text$ = "return"
gosub ExecuteIt
end

ExecuteIt:
    code = Compile(text$)
    if code = 0 lor not Execute(code) then
        printr CompilerError()
    endif
    return</FONT></PRE></BLOCKQUOTE>
<P><FONT color=#000000>stops with a runtime error "Return without gosub", 
because the runtime compiled code actually returns to the line after the 
"gosub", before finally ending when it reaches the "end" instruction. This 
returns control back to the instruction after the "Execute(code)" instruction 
which attempts to "return" again!</FONT></P>
<P><FONT color=#000000>Another issue is that the executed code may never return 
at all!<BR>Consider:</FONT></P>
<BLOCKQUOTE><PRE><FONT color=#000000>print "Starting"
Execute(Compile("while true: wend"))
print "Ending"</FONT></PRE></BLOCKQUOTE>
<P>The last line is never executed, because the dynamically compiled code 
("while true: wend") never exits, and control is never 
returned.</P></BODY></HTML>
